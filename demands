from collections import defaultdict

class BaseMVA(object):
    def __init__(self, loaded_data_file):
        self.data = loaded_data_file
        self.baseMVA_df = loaded_data_file["baseMVA"]
    
    ##BaseMVA PYOMO DICTIONARY DEFINITIONS
    #Base MVA (for param baseMVA)
    def baseMVA(self):
        if len(self.baseMVA_df['baseMVA']) > 1:
            print("More than one base MVA defined")
        else:
            return self.baseMVA_df['baseMVA'][0]

class Demands(object):
    def __init__(self, loaded_data_file):
        self.data = loaded_data_file
        self.bus = loaded_data_file["bus"]
        self.demand = loaded_data_file["demand"]
        self.baseMVA = float(loaded_data_file['baseMVA']['baseMVA'][0])

    ##DEMAND PYOMO DICTIONARY DEFINITIONS
    #Demand Identifiers (for Set D)
    def identifiers(self):
        return [demand_name for demand_name in self.demand['name']]

    '''
    Storing for Later
    
    #Demand Bus Mapping (for Set Dbs)
    # 
    # Pyomo mapping sets require a set of tuples for the index.
    #  
    # def bus_mapping(self):
    #     tuples = zip(self.demand['busname'], self.demand['name']) #creates iterator of tuples
    #     return tuples

    #Demand Bus Mapping (for Set Dbs)
    def bus_mapping(self):
        # tuples = zip(self.demand['busname'], self.demand['name']) #creates iterator of tuples
        # return tuples
            return self.demand.groupby('name')['busname'].agg(list).to_dict()

    '''

    def negatives(self):
        negatives = self.demand[self.demand['real'] < 0]
        return [negatives_name for negatives_name in negatives['name']]

    ###Demand Bus Mapping
    def bus_mapping(self):
        bus_demand = defaultdict(list)
        # Populate the dictionary with demands
        for bus_name, name in self.demand.groupby('busname')['name'].agg(list).items():
            bus_demand[bus_name] = name
        # Ensure every bus has an entry in the dictionary
        for bus in self.bus['name']:
            bus_demand[bus] # Since bus_branch is a defaultdict, this will automatically create an empty list if the bus is not found
        return(dict(bus_demand))

    #Real Power Demand (for Parameter PD, Real Power Demand)
    def real_demand(self):
        return self.demand.set_index('name')['real'] / self.baseMVA    

    #Reactive Power Demand
    def reactive_demand(self):
        return self.demand.set_index('name')['reactive'] / self.baseMVA   
    
    #Demand Value of Lost Load (for Parameter VOLL, Volume of Lost Load)
    def VOLL(self):
        return self.demand[['name', 'VOLL']].set_index('name')['VOLL'].T.to_dict()